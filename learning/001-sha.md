# Integrity

**Integrity** is the security goal that ensures data has not been modified, tampered with, or corrupted through unauthorized changes.

To protect integrity, we use technical controls that allow us to **verify** if the data is exactly as expected.

Think about downloading a file from the internet. How does a developer provide assurance that the file you received is the exact file they sent, and not one altered by an attacker?

They provide a fixed-length codeâ€”a cryptographic "fingerprint"â€”calculated from the file's contents. This process is called **Hashing**. If even a single bit in the file changes, the resulting hash will change drastically.

Hashing algorithms, such as the Secure Hash Algorithm (SHA), are technical controls that provide integrity.

-----

## Terminal Practice: Hashing

Let's see this in action on your Kali system.

**Step 1:** Create a small file that we will verify later.

```bash
echo "My secret data is here." > data.txt
```

**Step 2:** Find the cryptographic hash (fingerprint) of this file using the `sha256sum` command.

### ðŸ¤” Quick Question: Is this similar to what Git uses?

That is an extremely sharp observationâ€”you are exactly right\!

The way Git detects changes to a file is fundamentally the same principle: **cryptographic hashing** (Git uses SHA-1 internally for its objects).

1.  **Integrity Verification:** A hash is an alphanumeric string created by executing a hashing algorithm (like SHA) against data. If the calculated hash is different from the original hash, it verifies that the file has lost its integrity (it has been modified).
2.  **Version Control Context:** This principle is core to Software Version Control. When you "commit" a file, Git hashes its contents. If you change the file, the hash changes, and Git knows the file is modified.
3.  **Code Security:** This also extends to **Code Signing**, which uses a hash to verify that the code you're running has not been modified since the publisher released it.

### Kali Linux Hashing Script

Here is the practice script, adapted to use the native `sha256sum` command.

```bash
#!/bin/bash

# Define the file path
# Using /tmp is good practice for temporary files
# that don't need to persist when a container stops.
TEMP_FILE="/tmp/mock.txt"

# 1. Create our original file
echo "My secret data is here." > $TEMP_FILE

# 2. Calculate the "baseline" hash. This is the "known good" value.
#    sha256sum is the standard GNU/Linux command for this.
echo "--- Original Hash ---"
sha256sum $TEMP_FILE

# 3. Now, modify the file (corrupting its original integrity)
echo "Addition." >> $TEMP_FILE

# 4. Calculate the hash again.
echo "--- Modified Hash ---"
sha256sum $TEMP_FILE

# 5. Clean up
rm $TEMP_FILE
```

### Example Output

When you run the script, you will see definitive proof of the change:

```bash
--- Original Hash ---
460e83cca0ffc6d26aaafe76c301513a54bae243c6cf9d4e525625e72b8cde60  /tmp/mock.txt
--- Modified Hash ---
5c7deb8f16261b0e51a0de4e1b675eb7908ca2b8e41a3526286a50cfde10c0c5  /tmp/mock.txt
```

### Analysis of the Result

That is the exact, crucial demonstration\! You have successfully used the **hashing** mechanismâ€”the primary technical control for **Integrity**.

Here is what your output confirms:

1.  **Baseline Hash:** The first command, `sha256sum $TEMP_FILE`, created the first hash: `460e83cca0ffc6d26aaafe...`. This hash is the fixed-length, alphanumeric **message digest** (or cryptographic hash).
2.  **Integrity Loss:** The command `echo "Addition." >> $TEMP_FILE` modified the file's contents. When you ran `sha256sum` again, the resulting hash was **completely different**: `5c7deb8f16261b0e51...`.
3.  **Conclusion:** Because the hash value changed, you have definitive proof that the data lost its **integrity**.

This concept of verifying integrity via hashing is used everywhere, from checking system files for tampering to verifying software downloads.