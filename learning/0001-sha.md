# Integrity

**Integrity** is the security goal that ensures data has not been modified, tampered with, or corrupted through unauthorized changes.

To protect integrity, we use technical controls that allow us to **verify** if the data is exactly as expected.

Think about downloading a file from the internet. How does a developer provide assurance that the file you received is the exact file they sent, and not one altered by an attacker?

They provide a fixed-length code—a cryptographic "fingerprint"—calculated from the file's contents. This process is called **Hashing**. If even a single bit in the file changes, the resulting hash will change drastically.

Hashing algorithms, such as the Secure Hash Algorithm (SHA), are technical controls that provide integrity.

---
## Terminal Practice: Hashing

Let's see this in action, as you requested! You can run this directly on your macOS terminal or in a Kali Docker container.

**Step 1:** Create a small file that we will verify later.

```bash
echo "My secret data is here." > data.txt
```

**Step 2:** Find the cryptographic hash (fingerprint) of this file using the `sha256sum` command.

Is this similar to what git uses to know a file has changes?

That is an extremely sharp observation—you are exactly right!

The way Git detects changes to a file is fundamentally the same principle we just discussed: **cryptographic hashing**.

Here is how that connection works based on the sources:

1.  **Integrity Verification:** A hash is an alphanumeric string created by executing a hashing algorithm (like SHA) against data. If the calculated hash is different from the original hash, it verifies that the file has lost its integrity, meaning it has been modified.
2.  **Version Control Context:** This principle is core to **Software Version Control**. Git, specifically, was developed as a version-control system to manage source code.
3.  **Code Security:** When dealing with source code integrity, **Code Signing** uses a digital signature that includes a hash to verify the code has not been modified since the publisher released it.

<mark>Answer</mark>

```bash
bash learning/0001-sha.sh
460e83cca0ffc6d26aaafe76c301513a54bae243c6cf9d4e525625e72b8cde60  /tmp/mock.txt
5c7deb8f16261b0e51a0de4e1b675eb7908ca2b8e41a3526286a50cfde10c0c5  /tmp/mock.txt
```

That is the exact, crucial demonstration! You have successfully used the **hashing** mechanism—the primary technical control for **Integrity**.

Here is what your output confirms, based on the source material:

1.  **Baseline Hash:** The command `echo "My secret data is here." > /tmp/mock.txt` created the file, and `sha256sum /tmp/mock.txt` created the first hash: `460e83cca0ffc6d26aaafe76c301513a54bae243c6cf9d4e525625e72b8cde60 /tmp/mock.txt`. This hash is the fixed-length, alphanumeric **message digest** (or cryptographic hash).
2.  **Integrity Check (Loss):** The command `echo "Addition." >> /tmp/mock.txt` modified the file's contents (by appending data). When you ran `sha256sum` again, the resulting hash was completely different: `5c7deb8f16261b0e51a0de4e1b675eb7908ca2b8e41a3526286a50cfde10c0c5 /tmp/mock.txt`.
3.  **Conclusion:** Because the hash value changed, you have definitive proof that the data lost its **integrity**.

This concept of verifying integrity via hashing is used everywhere, from checking system files against a baseline to downloading software updates.
